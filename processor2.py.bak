import functools
import json
import traceback

from collections import OrderedDict

class ChannelEnd(object):
    def __init__(self, component):
        self.component = component
        self.rx_value = None
        self.rx_subscribers = set()

    @property
    def rx(self):
        return self.rx_value

    def set_rx(self, value):
        diff = self.rx_value == value
        self.rx_value = value

        for cb in self.rx_subscribers:
            cb(self, diff)

    def subscribe_to_rx(self, callback):
        self.rx_subscribers.add(callback)

    # setter = set_rx of other chanend
    def setup_tx(self, setter):
        self.tx = property(None, setter)

class Component(object):
    def __init__(self):
        self.config = {
            "channel_keys": set()
        }

        self.state = {}

    def get_channels_out(self, channels_in, clock_phase):
        return {}

    def update_state(self, channels_in, clock_phase):
        return False

    def add_channel(self, key):
        self.config["channel_keys"].add(key)

class ComponentConnectionOrchestrator(object):
    def __init__(self):
        self.components = set()
        self.connections = {}

        self.channel_state = {}

        self.clock_phase = 0

    def add_connection(self, a, b):
        assert a not in self.connections
        assert b not in self.connections

        self.connections[a] = b
        self.connections[b] = a

        self.channel_state[a] = None
        self.channel_state[b] = None

        self.components.update([a[0],b[0]])

    def get_channels_in(self, component):
        return dict((channel_key, self.channel_state[(component,channel_key)] if (component,channel_key) in self.channel_state else None) for channel_key in component.config["channel_keys"])

    # clock and propagate
    def step(self):
        self.clock_phase = 1 - self.clock_phase

        dirty_components = set()

        for component in self.components:
            stateful = component.update_state(self.get_channels_in(component), self.clock_phase)
            if stateful:
                dirty_components.add(component)

        while dirty_components:
            component = dirty_components.pop()

            channels_out = component.get_channels_out(self.get_channels_in(component), self.clock_phase)

            for channel_key in component.config["channel_keys"]:
                if (component, channel_key) not in self.connections:
                    continue

                dest = self.connections[(component, channel_key)]
                if channels_out[channel_key] != self.channel_state[dest]:
                    dirty_components.add(dest[0])

                self.channel_state[dest] = channels_out[channel_key]

    def step_multi(self):
        i = raw_input("Enter e to stop. Enter nothing and press enter to step 1 phase ")
        while i != "e":
            self.step()
            i = raw_input("Enter e to stop. Enter nothing and press enter to step 1 phase ")

class DictBroadcastBus(Component):
    def __init__(self):
        super(DictBroadcastBus, self).__init__()

        self.bus_channel_counter = 0

    def add_bus_channel(self):
        key = str(self.bus_channel_counter)
        self.add_channel(key)
        self.bus_channel_counter += 1
        return key

    def get_channels_out(self, channels_in, clock_phase):
        out = dict(itertools.chain.from_iterable(ci.iteritems() for ci in channels_in.itervalues()))
        return dict((ck, out) for ck in self.channel_keys)

class ChannelBuffer(Component):
    def __init__(self):
        super(ChannelBuffer, self).__init__()

        self.add_channel("A")
        self.add_channel("B")

        self.state["A"] = None
        self.state["B"] = None

    def get_channels_out(self, channels_in, clock_phase):
        return {
            "A": self.state["B"],
            "B": self.state["A"]
        }

    def update_state(self, channels_in, clock_phase):
        if clock_phase == 0:
            self.state["A"] = channels_in["A"]
            self.state["B"] = channels_in["B"]
        
        print self.state

        return True

class InstructionFetch(Component):
    def __init__(self, instructions):
        super(InstructionFetch, self).__init__()

        self.add_channel("instruction")

        self.config["instructions"] = instructions

        self.state["instruction"] = ("NOOP",0,0,0,0)
        self.state["pc"]          = 0

    def get_channels_out(self, channels_in, clock_phase):
        return {
            "instruction": self.state["instruction"],
            "pc": self.state["pc"]
        }

    def update_state(self, channels_in, clock_phase):
        if clock_phase == 0:
            self.state["pc"] = self.state["pc"] + 1
            # if input_values["set_pc_en"]:
            #     self.state["pc"] = input_values["set_pc_val"]
            # else:

        if clock_phase == 1:
            self.state["instruction"] = self.config["instructions"][self.state["pc"]]

        return True

class Decoder(Component):
    def __init__(self):
        super(Decoder, self).__init__()

        self.add_channel("instruction")
        self.add_channel("decoded_instruction")

    def get_channels_out(self, channels_in, clock_phase):
        return {
            "instruction": None,
            "decoded_instruction": channels_in["instruction"],
        }
    
    def update_state(self, channels_in, clock_phase):
        return False


class Processor(object):
    def __init__(self, instructions, data):
        self.cco = ComponentConnectionOrchestrator()

        self.object_lookup = {}
        self.name_lookup = {}

        self.setup_components(instructions, data)
    
    def step(self):
        self.cco.step()

    # maybe one day move to something like instruction_fetch.instruction
    # and have it = ChannelEnd()
    # and then we can type them
    # and instead of having the updates returned during update, we just tx to them which is only enabled when that function is called
    # ie mark it as read only for everything else
    # need some way of capturing the txs = either have a handler/callback or collect and clear afterwards?
    # maybe make use of with? idk
    # can then have rx and tx and overload assignment/read
    # allow only rx to be read, and tx only to be written, and tx is conditional
    def setup_components(self, instructions, data):
        connect = self.cco.add_connection

        instruction_fetch = InstructionFetch(instructions)
        instruction_fetch_cb = ChannelBuffer()
        connect((instruction_fetch, "instruction"), (instruction_fetch_cb, "A"))

        decoder = Decoder()
        connect((instruction_fetch_cb,"B"),(decoder,"instruction"))

        decoder_cb = ChannelBuffer()
        connect((decoder, "decoded_instruction"), (decoder_cb, "A"))

        #reservation_station = ReservationStation()
        #p.add_connection((reservation_station,"ALU_EU"),())
        #p.add_connection((reservation_station,"LDST_EU"),())
        
        # decoded instructions go into RS
        # when issued get their operands resolved
        # execute
        # changes to registers go into ROB
        # changes to memory are done within the EU, ie no need for a ROB

        # nice and hacky
        self.components = dict(i for i in locals().iteritems() if isinstance(i[1],Component))

