<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Debug</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <style media="screen">
      html, html>body { margin:0; padding:0; overflow:hidden; height:100% }
      #processor-view { height:100%; width:100% }

      text {
        font-family: monospace;
      }

      .input-label, .output-label {
        font-size: 8px
      }
    </style>
  </head>
  <body>
    <svg id="processor-view" viewBox="0 0 1000 1000">

    </svg>
    <script>
    //<![CDATA[
    /*
    Ok, only one data bind. Use promises to do both structure and state get,
    combine them into one data binding and then we can update the data on get
    and just recall update_component
    */

    /*

    Ok, cant replace data on load completely due to replacing js added things.
    either separate them out or do a manual copy
    */
    window.processor = {};
    (function(processor){
      var svg = d3.select("#processor-view")

      let structure_get = new Promise(function(resolve, reject) {
        d3.request('processor/structure')
          .get(function(error, data){
            if (error) reject(error);
            resolve(data);
          });
      });

      let state_get = new Promise(function(resolve, reject) {
        d3.request('processor')
          .get(function(error, data){
            if (error) reject(error);
            resolve(data);
          });
      });

      Promise.all([structure_get, state_get])
        .then(function(result){
          processor.structure = JSON.parse(result[0].response);
          processor.state     = JSON.parse(result[1].response);

          Object.keys(processor.structure["components"]).forEach(function (key) {
            processor.structure["components"][key]["name"] = key
          });

          processor.component_data = Object.keys(processor.structure["components"]).map(function(key){
            return {
              "structure": processor.structure["components"][key],
              "state": processor.state["components"][key],
              "pos": {
                "x": Math.random()*1000,
                "y": Math.random()*1000
              },
              "size": {
                "width": 0,
                "height": 0
              }
            }
          })


          var component = svg
            .selectAll('.component')
            .data(processor.component_data, function(d){ return d.structure.name; })
            ;

          var component_drag = d3.drag()
            .subject(function(d){
              return d.pos
            })
            .on("start", function(d) {
              d3.select(this).raise().classed("active", true);
            })
            .on("drag", function(d) {
              d.pos.x = d3.event.x
              d.pos.y = d3.event.y

              d3.select(this)
                .attr("transform", function(d){
                  return "translate(" + d.pos.x + "," + d.pos.y + ")"
                });
            })
            .on("end", function(d) {
              d3.select(this).classed("active", false);
            })
            ;

          // give it its own datum, therefore it knows when its been created or not
          function basic_render(d) {

            if (50 > d.size.height) {
              d.size.height = 50
            }

            if (50 > d.size.width) {
              d.size.width = 50
            }
          }

          function register_file_render(d) {
            var fo = d3.select(this)
              .selectAll('.register-file-render')
              .data([d])
              ;

            fo
              .enter()
                .append('foreignObject')
                .classed('register-file-render', true)
                .attr('width', 120)
                .attr('height', 200)
                .call(function(foreignObject){
                  foreignObject
                    .append('xhtml:html')
                    .attr('xmlns', "http://www.w3.org/1999/xhtml")
                    .append('xhtml:body')
                    .attr('style', 'font-size: 10px; overflow: auto; height: 100%;')
                    .append('xhtml:table')
                })

              .merge(fo)
                .select('html')
                .select('body')
                .select('table')
                .call(function(body){
                  var registers = body
                    .selectAll('.register')
                    .data(function(d) {
                      return d.state.registers.map(function(r,i){
                        return {
                          'value': r,
                          'reg_read_sel1': d.state.input_values.reg_read_sel1 == i,
                          'reg_read_sel2': d.state.input_values.reg_read_sel2 == i,
                          'write_sel': d.state.input_values.write_sel == i && d.state.input_values.write_enable
                        }
                      });
                    })

                  registers
                    .enter()
                      .append('xhtml:tr')
                      .classed('register', true)
                      .call(function(row){
                        row
                          .append('td')
                          .text(function(d,i){ return i })

                        row
                          .append('td')
                          .classed('register-value', true)

                        row
                          .append('td')
                          .classed('register-status', true)
                      })
                    .merge(registers)
                      .call(function(selection){
                        selection
                          .select('td.register-value')
                          .text(function(d){ return d.value })
                      })
                      .call(function(selection){
                        selection
                        .select('td.register-status')
                        .text(function(d){
                          let ary = [];
                          if (d.reg_read_sel1) ary.push('rs0');
                          if (d.reg_read_sel2) ary.push('rs1');
                          if (d.write_sel)     ary.push('ws');
                          return ary.join(',')
                        })

                      })
                      ;
                })


            if (120 > d.size.width)  d.size.width  = 120
            if (200 > d.size.height) d.size.height = 200
          }

          function instruction_memory_render(d) {
            var fo = d3.select(this)
              .selectAll('.instruction-memory-render')
              .data([d])
              ;

            fo
              .enter()
                .append('foreignObject')
                .classed('instruction-memory-render', true)
                .attr('width', 120)
                .attr('height', 200)
                .call(function(foreignObject){
                  foreignObject
                    .append('xhtml:html')
                    .attr('xmlns', "http://www.w3.org/1999/xhtml")
                    .append('xhtml:body')
                    .attr('style', 'font-size: 10px; overflow: auto; height: 100%; font-family: monospace;')
                    .append('xhtml:table')
                    .attr('style', 'width: 100%; border-collapse: collapse;')
                })

              .merge(fo)
                .select('html')
                .select('body')
                .select('table')
                .call(function(body){
                  var entries = body
                    .selectAll('.instruction-memory-entry')
                    .data(function(d) {
                      return [0,1,2,3].map(function(i){
                        let idx = d.state.input_values.address + i

                        return {
                          "index": idx,
                          "value": d.structure.instructions[idx],
                          "current": i == 0
                        }
                      })
                    })

                  entries
                    .enter()
                      .append('xhtml:tr')
                      .attr('style', function(d){ return d.current ? 'border-bottom: 1px solid #8d8d8d;' : ''; })
                      .classed('instruction-memory-entry', true)
                      .call(function(row){
                        row
                          .append('td')
                          .classed('instruction-memory-entry-index', true)

                        row
                          .append('td')
                          .classed('instruction-memory-entry-value', true)

                      })
                    .merge(entries)
                      .call(function(selection){
                        selection
                          .select('td.instruction-memory-entry-index')
                          .text(function(d){ return d.index })
                      })
                      .call(function(selection){
                        selection
                          .select('td.instruction-memory-entry-value')
                          .text(function(d){ return d.value })
                      })
                      ;
                })


            if (120 > d.size.width)  d.size.width  = 120
            if (70 > d.size.height) d.size.height = 70
          }

          var component_render_map = {
            "Multiplexer": basic_render,
            "DataMemory": basic_render,
            "Incrementer": basic_render,
            "RegisterFile": register_file_render,
            "InstructionSplit": basic_render,
            "And": basic_render,
            "InstructionMemory": instruction_memory_render,
            "PipelineBuffer": basic_render,
            "Latch": basic_render,
            "Constant": basic_render,
            "Or": basic_render,
            "Decoder": basic_render,
            "ALU": basic_render,
          };

          function setup_inputs(component_d) {
            var input = d3.select(this)
              .append('g')
              .classed('input-group', true)
              .selectAll('.input')
              .data(function(d){
                return component_d.structure.input_keys.map(function(key) {
                  return {
                    'key': key,
                    'value': component_d.state.input_values[key]
                  }
                });
              })

            var inputenter = input
              .enter()
                .append('g')
                .classed('input', true)
                .attr('data-input-id', function(d){ return d.key })
                .attr('transform', function(d,i){
                  return 'translate(-5,' + (i)*40 + ')'
                })
                ;

            inputenter
              .append('text')
              .classed('input-label', true)
              .attr('y', 15)
              .attr("dominant-baseline", "text-after-edge")
              .attr('text-anchor', 'end')
              .text(function(d){ return d.key })
              ;

            inputenter
              .append('rect')
              .classed('input-value-rect', true)
              .style("fill", "#ffffff")
              .style("stroke", "#999999")
              ;

            inputenter
              .append('text')
              .classed('input-value', true)
              .attr('y', 20)
              .attr('x', -2)
              .attr('text-anchor', 'end')
              .attr("dominant-baseline", "text-before-edge")
              ;


            if (component_d.structure.input_keys.length*40 > component_d.size.height) {
              component_d.size.height = component_d.structure.input_keys.length*40
            }
          }

          function update_inputs(component_d) {
            var input = d3.select(this)
              .select('.input-group')
              .selectAll('.input')
              .data(function(d){
                return component_d.structure.input_keys.map(function(key) {
                  return {
                    'key': key,
                    'value': component_d.state.input_values[key]
                  }
                });
              })

            var input_value = input
              .select('.input-value')
              .text(function(d){ return d.value })
              .each(function(d){
                d.bbox = this.getBBox();
              })
              ;

            input
              .select('.input-value-rect')
              .each(function(d){
                d3.select(this)
                  .attr("x", d.bbox.x - 2)
                  .attr("y", d.bbox.y - 2)
                  .attr("width", d.bbox.width + 4)
                  .attr("height", d.bbox.height + 4)
              })
              ;
          }

          function setup_outputs(component_d) {
            var output = d3.select(this)
              .append('g')
              .classed('output-group', true)
              .selectAll('.output')
              .data(function(d){
                return component_d.structure.output_keys.map(function(key) {
                  return {
                    'key': key,
                    'value': component_d.state.output_values[key]
                  }
                });
              })

            var outputenter = output
              .enter()
                .append('g')
                .classed('output', true)
                .attr('data-output-id', function(d){ return d.key })
                .attr('transform', function(d,i){
                  return 'translate(' + (component_d.size.width + 5) + ',' + (i)*40 + ')'
                })
                ;

            outputenter
              .append('text')
              .classed('output-label', true)
              .attr('y', 15)
              .attr("dominant-baseline", "text-after-edge")
              .text(function(d){ return d.key })
              ;


            outputenter
              .append('rect')
              .classed('output-value-rect', true)
              .style("fill", "#ffffff")
              .style("stroke", "#999999")
              ;

            outputenter
              .append('text')
              .classed('output-value', true)
              .attr('y', 20)
              .attr('x', 2)
              .attr("dominant-baseline", "text-before-edge")
              ;

            if (component_d.structure.output_keys.length*40 > component_d.size.height) {
              component_d.size.height = component_d.structure.output_keys.length*40
            }
          }

          function update_outputs(component_d) {
            var output = d3.select(this)
              .select('.output-group')
              .selectAll('.output')
              .data(function(d){
                return component_d.structure.output_keys.map(function(key) {
                  return {
                    'key': key,
                    'value': component_d.state.output_values[key]
                  }
                });
              })
              .attr('transform', function(d,i){
                return 'translate(' + (component_d.size.width + 5) + ',' + (i)*40 + ')'
              })

            var output_value = output
              .select('.output-value')
              .text(function(d){ return d.value })
              .each(function(d){
                d.bbox = this.getBBox();
              })
              ;

            output
              .select('.output-value-rect')
              .each(function(d){
                d3.select(this)
                  .attr("x", d.bbox.x - 2)
                  .attr("y", d.bbox.y - 2)
                  .attr("width", d.bbox.width + 4)
                  .attr("height", d.bbox.height + 4)
              })
              ;
          }

          component
            .enter()
              .append('g')
              .classed('component', true)
              .attr('data-component-id', function(d){ return d.name })
              .attr("transform", function(d){
                return "translate(" + d.pos.x + "," + d.pos.y + ")"
              })
              .call(component_drag)
              // these should be merged?
              // can leave here for now becuase it doesnt change
              .each(setup_inputs)
              .each(setup_outputs)
              .call(function(selection){
                selection
                  .append('rect')
                  .lower()
                  .classed('component-container', true)
                  .attr('fill', '#ffffff')
                  .attr('stroke', '#999999')

                selection
                  .append('text')
                  .attr('y', '-5')
                  .text(function(d){ return '(' + d.structure.type + ')'});

                selection
                  .append('text')
                  .attr('y', '-25')
                  .text(function(d){ return d.structure.name});
              })
            .merge(component)
              .each(update_inputs)
              .each(update_outputs)
              .each(function(d){
                component_render_map[d.structure.type].call(this, d);
              })
              .call(function(selection){
                selection
                  .select('.component-container')
                  .attr('width', function(d){ return d.size.width } )
                  .attr('height', function(d){ return d.size.height } );
              })
              ;

          function update(){
            new Promise(function(resolve, reject) {
              d3.request('processor')
                .header("Content-Type", "application/x-www-form-urlencoded")
                .send("POST", "steps=1", function(error, data){
                  if (error) reject(error);
                  resolve(data);
                });
            }).then(function(result){
              processor.state = JSON.parse(result.response);

              Object.keys(processor.structure["components"]).forEach(function(key, i){
                processor.component_data[i]["state"] = processor.state["components"][key]
              })

              /*
              internet says to avoid doing this and just store component. ... .data
              */
              var component = svg
                .selectAll('.component')
                .data(processor.component_data, function(d){ return d.structure.name; })
                ;

              component
                .each(update_inputs)
                .each(update_outputs)
                .each(function(d){
                  component_render_map[d.structure.type].call(this, d);
                })
                .call(function(selection){
                  selection
                    .select('.component-container')
                    .attr('width', function(d){ return d.size.width } )
                    .attr('height', function(d){ return d.size.height } );
                })
                ;
            })

            setTimeout(update, 200);
          }

          update();
        })

    })(window.processor);
    //]]>
    </script>
  </body>
</html>
